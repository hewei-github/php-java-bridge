PHP/Java Bridge protocol version 4.2.2

Requests are marked with "->", responses with "<-".  The server
continues to process requests until EOF. Only the first character is
significant.

The communication must begin with [C]reateInstance or [I]nvoke. The
server responds with a single ARG which also carries the last request
context ID. The request context ID is your request context, for
example the location of a cell where the response should be stored; a
structure or something like that. In PHP for example we allocate a
pval and pass it as the ID to the Invoke or Create request. When the
response arrives, we receive our ID along with the result so we know
exactly where to store the result. Context ID's are optional and can
be switched off, if the client can keep track of the context, see
NOTES below.

Example:

     $o = new java("java.lang.Long", 6);
     $o->toString(); // discard result

->  <CreateInstance value="java.lang.Long" predicate="I" id="78532"> 
      <Long value="6"/> 
    </CreateInstance>

<-  <Object value="1" predicate="O" id="78532"/>

->  <Invoke value="1" method="toString" predicate="I" id="0">
    </Invoke>

<-  <Object value="2" predicate="O" id="0"/>

->  <Unref value="2" />

->  <Unref value="1" />

A second example which shows how to avoid round-trips. 

     $o = new java("java.lang.Long", 6);
     $o->toString(); // discard result

->  <K p="2" v="java.lang.Long" i="0"> 
      <L v="6" /> 
    </K

->  <Y p="3" v="1" m="toString" i="0"></Y>

->  <U value="1" /> # result from CreateInstance


Optional requests:

All aquired [O]bject handles may be destroyed by invoking U (destroy).
However, the server tracks all handles and automatically destroys them
after EOF. It is an error to further reference destroyed handles.

If [F]inish is called, the server closes or recycles the connection
and responds with F p=A, if the connection has been recycled, p=E
otherwise. Instead of sending <F p=E/> and waiting for the response,
it is also possible to simply close the connection.



Main requests:


->
CreateInstance:
<C v=name p=C|I [i=ID]> ...ARGS...
</C>
v: string
p: char (Reference[C]lass, Create[I]nstance)
i: unsigned long

->
Invoke:
<I v=object m=method p=P|I [i=ID]> ...ARGS...
</I>
v: unsigned long
m: string
p: char (examine[P]roperty, [I]nvoke method)
i: unsigned long

When v=0, the call is directed to the current request-handling
instance of the java bridge.

->
ReferenceClass (alternate form)
<H p=1|2|3 v=name [i=ID]> ...ARGS...
</H>
p: char 
v: string
i: unsigned long
Predicate 2 does not write a result, but stores a result proxy under ++CID.
Predicate 3 does not write a result and does not create a result proxy.

->
CreateInstance (alternate form)
<K p=1|2|3 v=name [i=ID]> ...ARGS...
</K>
p: char
v: string
i: unsigned long
Predicate 2 does not write a result, but stores a result proxy under ++CID.
Predicate 3 does not write a result and does not create a result proxy.

->
PropertyAccess (alternate form)
<G p=1|2|3 v=object m=method [i=ID]> ...ARGS...
</G>
p: char 
v: unsigned long
m: string
i: unsigned long
Predicate 2 does not write a result, but stores a result proxy under ++CID.
Predicate 3 does not write a result and does not create a result proxy.

->
Invoke (alternate form)
<Y p=1|2|3 v=object m=method [i=ID]> ...ARGS...
</Y>
p: char (examine[P]roperty, [I]nvoke method)
v: unsigned long
m: string
i: unsigned long
Predicate 2 does not write a result, but stores a result proxy under ++CID.
Predicate 3 does not write a result and does not create a result proxy.


When v=0, the call is directed to the current request-handling
instance of the java bridge.



ARGS or response:
<->
String:
<S v=str [i=ID] />
v: string
i: unsigned long (reply only)

<->
Boolean:
<B v=T|F [i=ID] />
v: char ([T]rue, [F]alse)
i: unsigned long (reply only)

->
Boolean:(alternate form)
<T v=1]OTHER />
v: char [1]: true, everything else: false

<->
Long: 
<L v=l p=[O|A] [i=ID] />
v: unsigned long
p: char (p[O]sitive, neg[A]tive)
i: unsigned long (reply only)

->
Long: (alternate form)
<J v=l />
v: long (signed number)

<->
Double:
<D v=d [i=ID] />
v: double
i: unsigned long (reply only)

->
Object:
<O v=object />
v: unsigned long
NULL values can be sent as either v="" or v="0"

<-
Object:
<O v=object m=TYPE p=TYPE n=[T|F] [i=ID] />
v: unsigned long
m: string
p: char ([A]rray/Map, [C]ollection, [O]bject, [E]xception)
n: char result can be cached (T) or not (F)
i: unsigned long 

<-
Null:
<N [i=ID] />
i: unsigned long 

<-
Void:
<V m=[T|F] [i=ID] />
i: unsigned long 
n: char result can be cached (T) or not (F)

<-
Apply:
<A v=object p=cname m=fname n=param# [i=ID]> ...PAIRS...
</A>
v: unsigned long
p: string
m: string
n: unsigned long
i: unsigned long
Result can be used to send back the result of the current apply
call. If v is null, the function name p must be searched in the
"current" environment.

->
Result:
<R [i=ID]> ...ARG...
</R>
i: unsigned long

<->
Exception:
<E v=object m=stringRepresentation [i=ID] />
v: unsigned long
m: string
i: unsigned long

->  (or <->, see below)
Composite:
<X t=A|H [i=ID] /> ...PAIRS...
</X>
t: char ([A]rray, [H]ashtable)
i: unsigned long (reply only)

->  (or <->, see below)
Pair:
<P [t=N|S v=key]> ...ARG...
</P>
t: char (key is [N]umeric, [S]tring or doesn't exist (if X=A))
v: unsigned long (if X=H and t=N)
v: string (if X=H and t=S)



OPTIONAL requests:
->
Destroy:
<U v=object />
v: unsigned long

<->
EndConnection:
<F p=A|E />
p: char (Keep [A]live, [E]nd connection)




NOTES:

If the first byte is 0177, the following byte has a special meaning:

Bit 1 0
-------
         keep object  keep array, send   binary             comment/php
          identity    Map, Coll.    ID     data              impl. (pure
                      identity                               PHP or C)

    - -    no           no         yes    base64 encoded     default
    0 0    yes          yes        no     binary             PHP
    0 1    no           yes        no     binary             PHP
    1 0    no           yes        no     base64 encoded     PHP
    1 1    yes          yes        no     base64 encoded     PHP

Bit 2,3,4: log level (from java.log_level)

Bit 5: always 0

Bit 6: set to 1 if bit[0,1] are used
Bit 7: set to 1 if bit[2,4] are used

It is possible to send the header even though the connection has
already been established. The bridge will ignore the header if the
second byte is not 0xFF. This is convenient as some clients don't know
if they use a fresh or a recycled connection.

Otherwise the back end interprets the following two bytes (low/high)
as the length of the following context string. The client may initiate
such a context switch if it has received a context ID belonging to a
different ContextServer from a client (e.g.: PhpCGIServlet) while
keeping a persistent connection to a ContextRunner.

It is possible to "ping" the server by sending it the byte 0x0. If
alive it will send back a 0x0.
