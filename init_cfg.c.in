/*-*- mode: C; tab-width:4 -*-*/

/* mktemp */
#include <stdlib.h>

/* time */
#include <time.h>

#include "protocol.h"
#include "php_java.h"
#include "java_bridge.h"
#include "php_java_snprintf.h"

#ifndef EXTENSION_DIR
#error EXTENSION_DIR must point to the PHP extension directory
#endif

#ifndef CFG_CLASSPATH
#define CFG_CLASSPATH ""
#endif
#ifndef CFG_LD_LIBRARY_PATH
#define CFG_LD_LIBRARY_PATH ""
#endif

#ifndef CFG_JAVA
#if @COND_GCJ@ == 1
#define CFG_JAVA ""
#else
#define CFG_JAVA "@PHP_JAVA_BIN@"
#endif
#endif

#ifndef CFG_JAVA_HOME
#if @COND_GCJ@ == 1
#define CFG_JAVA_HOME ""
#else
#define CFG_JAVA_HOME "@PHP_JAVA@"
#endif
#endif

#ifndef BRIDGE_VERSION
#define BRIDGE_VERSION "@BRIDGE_VERSION@"
#endif

const char * const EXT_GLOBAL (bridge_version) = BRIDGE_VERSION;

EXT_EXTERN_MODULE_GLOBALS(EXT)

/*
 * check for CGI environment and set hosts so that we can connect back
 * to the sever from which we were called.
 */
static void override_ini_from_cgi(void) {
  static const char on[]="User";
  static const char off[]="Off";
  static const char key_socketname[]="java.socketname";
  static const char key_hosts[]="java.hosts";
  static const char key_servlet[] = "java.servlet";
  char *hosts;
  EXT_GLOBAL(cfg)->is_cgi_servlet=0;
  EXT_GLOBAL(cfg)->is_fcgi_servlet=0;
  
  if ((hosts=getenv("X_JAVABRIDGE_OVERRIDE_HOSTS"))) {
	switch(*hosts) {
	case '/': 				/* this is fast cgi, override
							   information will be passed via
							   X_JAVABRIDGE_REDIRECT header (see
							   override_ini_for_redirect()). */
	  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet,
						   (char*)on, sizeof on,
						   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP);
	  EXT_GLOBAL(cfg)->socketname_set = 0;
	  EXT_GLOBAL(cfg)->is_cgi_servlet=1;
	  EXT_GLOBAL(cfg)->is_fcgi_servlet=1;
	  break;

	default:					/* cgi binary with redirect
								   information */
	  {
		char *kontext, *host = strdup(hosts);
		kontext = strchr(host, '/');
		if(kontext) *kontext++=0;
		zend_alter_ini_entry((char*)key_hosts, sizeof key_hosts,
							 host, strlen(host)+1,
							 ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP);
		zend_alter_ini_entry((char*)key_socketname, sizeof key_socketname,
							 (char*)off, sizeof off,
							 ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP);
		EXT_GLOBAL(cfg)->socketname_set = 0;
		if(!kontext) {
		  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet,
							   (char*)on, sizeof on,
							   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP);
		} else {
		  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet,
							   (char*)kontext, strlen(kontext)+1,
							   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP);
		}
		free(host);
	  }
	  /* fall through */
	case 0:					/* cgi binary, but redirect is off */
	  EXT_GLOBAL(cfg)->is_cgi_servlet=1;
	}
  }
}

#ifndef CFG_JAVA_SOCKET_INET
#ifdef HAVE_ABSTRACT_NAMESPACE
static void init_socket(void) {
  static const char * const bridge="@java-bridge-";
  size_t len = strlen(bridge)+ sizeof(pid_t)*2; //assuming byte=8bit

  char *sockname=malloc(len+1);
  assert(sockname); if(!sockname) exit(6);

  EXT_GLOBAL(snprintf)(sockname, len+1, "%s%lx", bridge,(unsigned long)getpid());
  EXT_GLOBAL(cfg)->default_sockname = sockname;
}
#else 
static void init_socket(void) {
	int n;
	char*s=SOCKNAME;
	char *sockname=malloc(strlen(s)+1);
	assert(sockname); if(!sockname) exit(6);
	strcpy(sockname, s);
	n = mktemp(sockname);
	assert(n); if(!n) exit(6);
	EXT_GLOBAL(cfg)->default_sockname = sockname;
}
#endif
#else 
static void init_socket(void) {
  EXT_GLOBAL(cfg)->default_sockname = strdup(DEFAULT_PORT);
  assert(EXT_GLOBAL(cfg)->default_sockname); if(!EXT_GLOBAL(cfg)->default_sockname) exit(6);
}
#endif

void EXT_GLOBAL (init_cfg) (TSRMLS_D) {
  override_ini_from_cgi();

  init_socket();
  if(!(EXT_GLOBAL (ini_updated) &U_SOCKNAME)) {
	EXT_GLOBAL(cfg)->sockname=strdup(EXT_GLOBAL(cfg)->default_sockname);
	EXT_GLOBAL(cfg)->socketname_set=0;
  }
  if(!(EXT_GLOBAL (ini_updated) &U_SERVLET)) EXT_GLOBAL(cfg)->servlet=strdup(DEFAULT_SERVLET);
  if(!(EXT_GLOBAL (ini_updated) &U_HOSTS)) EXT_GLOBAL(cfg)->hosts=strdup("");
  if(!(EXT_GLOBAL (ini_updated) &U_WRAPPER)) EXT_GLOBAL(cfg)->wrapper=strdup(DEFAULT_WRAPPER);
  if(!(EXT_GLOBAL (ini_updated) &U_CLASSPATH)) EXT_GLOBAL(cfg)->classpath=strdup(CFG_CLASSPATH);
  if(!(EXT_GLOBAL (ini_updated) &U_LIBRARY_PATH)) EXT_GLOBAL(cfg)->ld_library_path=strdup(CFG_LD_LIBRARY_PATH);
  if(!(EXT_GLOBAL (ini_updated) &U_JAVA)) EXT_GLOBAL(cfg)->vm=strdup(CFG_JAVA);
  if(!(EXT_GLOBAL (ini_updated) &U_JAVA_HOME)) EXT_GLOBAL(cfg)->vm_home=strdup(CFG_JAVA_HOME);
  if(!(EXT_GLOBAL (ini_updated) &U_EXT_JAVA_COMPATIBILITY)) EXT_GLOBAL(cfg)->extJavaCompatibility=0;
  if(!(EXT_GLOBAL (ini_updated) &U_PERSISTENT_CONNECTIONS)) EXT_GLOBAL(cfg)->persistent_connections=1;
  if(!(EXT_GLOBAL (ini_updated) &U_LOGLEVEL)) {
	EXT_GLOBAL(cfg)->logLevel=strdup(DEFAULT_LEVEL);
	EXT_GLOBAL(cfg)->logLevel_val=atoi(DEFAULT_LEVEL);
  }
  if(!(EXT_GLOBAL (ini_updated) &U_LOGFILE)) EXT_GLOBAL(cfg)->logFile=strdup(LOGFILE);
  
  EXT_GLOBAL(ini_set)=~0;
  EXT_GLOBAL(ini_user)|=EXT_GLOBAL(ini_updated);
  EXT_GLOBAL(ini_updated)=0;

  EXT_GLOBAL(cfg)->can_fork = 
	!(EXT_GLOBAL (option_set_by_user) (U_SOCKNAME, EXT_GLOBAL(ini_user))) &&
	!(EXT_GLOBAL (option_set_by_user) (U_HOSTS, EXT_GLOBAL(ini_user))) &&
	!(EXT_GLOBAL (option_set_by_user) (U_SERVLET, EXT_GLOBAL(ini_user)));
}

void EXT_GLOBAL (destroy_cfg) (int EXT_GLOBAL (ini_updated) ) {
  assert(EXT_GLOBAL(ini_updated) == ~0);
  if(!(EXT_GLOBAL (ini_updated) &U_SERVLET)) free(EXT_GLOBAL(cfg)->servlet);
  if(!(EXT_GLOBAL (ini_updated) &U_WRAPPER)) free(EXT_GLOBAL(cfg)->wrapper);
  if(!(EXT_GLOBAL (ini_updated) &U_HOSTS)) free(EXT_GLOBAL(cfg)->hosts);

  if(!(EXT_GLOBAL (ini_updated) &U_SOCKNAME)) free(EXT_GLOBAL(cfg)->sockname); 
  free(EXT_GLOBAL(cfg)->default_sockname);

  if(!(EXT_GLOBAL (ini_updated) &U_CLASSPATH)) free(EXT_GLOBAL(cfg)->classpath);
  if(!(EXT_GLOBAL (ini_updated) &U_LIBRARY_PATH)) free(EXT_GLOBAL(cfg)->ld_library_path);
  if(!(EXT_GLOBAL (ini_updated) &U_JAVA)) free(EXT_GLOBAL(cfg)->vm);
  if(!(EXT_GLOBAL (ini_updated) &U_JAVA_HOME)) free(EXT_GLOBAL(cfg)->vm_home);
  if(!(EXT_GLOBAL (ini_updated) &U_LOGLEVEL)) free(EXT_GLOBAL(cfg)->logLevel);
  if(!(EXT_GLOBAL (ini_updated) &U_LOGFILE)) free(EXT_GLOBAL(cfg)->logFile);
}

/*
 * return true only if the _user_ has set the option to true (not
 * "off").
 */
short EXT_GLOBAL(option_set_by_user)(short option, int ini_user) {
  static const char off[]="Off";
  char *entry = 0;

  if((option & ini_user)==0) return 0;

  switch(option) {
  case U_LOGFILE: entry = EXT_GLOBAL(cfg)->logFile; break;
  case U_LOGLEVEL: entry = EXT_GLOBAL(cfg)->logLevel; break;
  case U_JAVA_HOME: entry = EXT_GLOBAL(cfg)->vm_home; break;
  case U_JAVA: entry = EXT_GLOBAL(cfg)->vm; break;
  case U_LIBRARY_PATH: entry = EXT_GLOBAL(cfg)->ld_library_path; break;
  case U_CLASSPATH: entry = EXT_GLOBAL(cfg)->classpath; break;
  case U_SOCKNAME: entry = EXT_GLOBAL(cfg)->sockname; break;
  case U_HOSTS: entry = EXT_GLOBAL(cfg)->hosts; break;
  case U_SERVLET: entry = EXT_GLOBAL(cfg)->servlet; break;
  case U_WRAPPER: entry = EXT_GLOBAL(cfg)->wrapper; break;
  case U_EXT_JAVA_COMPATIBILITY: return EXT_GLOBAL(cfg)->extJavaCompatibility;
  case U_PERSISTENT_CONNECTIONS: return EXT_GLOBAL(cfg)->persistent_connections;
  default: assert(0);
  }  

  if (!entry || !*entry) return 0;
  if(!strncasecmp(off, entry, 3)) {
	*entry=0;
	return 0;
  }
  return 1;
}

char *EXT_GLOBAL(get_servlet_context)(TSRMLS_D) {
  if(!EXT_GLOBAL(option_set_by_user)(U_SERVLET, JG(ini_user))) return 0;
  return JG(servlet);
}

char *EXT_GLOBAL(get_sockname)(TSRMLS_D) {
  if(!EXT_GLOBAL(option_set_by_user)(U_SOCKNAME, EXT_GLOBAL(ini_user)))
	return EXT_GLOBAL(cfg)->default_sockname;
  return EXT_GLOBAL(cfg)->sockname;
}

#ifndef PHP_WRAPPER_H
#error must include php_wrapper.h
#endif
