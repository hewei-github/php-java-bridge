/*-*- mode: C; tab-width:4 -*-*/

#include "php_java.h"

#ifdef HAVE_STRING_H
#include <string.h>
#endif

/* strncasecmp */
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif


/* mktemp */
#include <stdlib.h>

#include "protocol.h"
#include "java_bridge.h"

#ifndef EXTENSION_DIR
#error EXTENSION_DIR must point to the PHP extension directory
#endif

#ifndef CFG_CLASSPATH
#define CFG_CLASSPATH ""
#endif
#ifndef CFG_LD_LIBRARY_PATH
#define CFG_LD_LIBRARY_PATH ""
#endif

#ifndef CFG_JAVA
#if @COND_GCJ@ == 1
#define CFG_JAVA ""
#else
#define CFG_JAVA "@PHP_JAVA_BIN@"
#endif
#endif

#ifndef CFG_JAVA_HOME
#if @COND_GCJ@ == 1
#define CFG_JAVA_HOME ""
#else
#define CFG_JAVA_HOME "@PHP_JAVA@"
#endif
#endif

const char * const EXT_GLOBAL (bridge_version) = BRIDGE_VERSION;

EXT_EXTERN_MODULE_GLOBALS(EXT)

static const char on[]="On";
static const char on2[]="1";
static const char off[]="Off";
void EXT_GLOBAL(update_persistent_servlet_connections)(const char*new_value) {
	if((EXT_GLOBAL (ini_set) &U_PERSISTENT_SERVLET_CONNECTIONS)) free(EXT_GLOBAL(cfg)->persistent_servlet_connections);
	EXT_GLOBAL(cfg)->persistent_servlet_connections=strdup(new_value);
	assert(EXT_GLOBAL(cfg)->persistent_servlet_connections); if(!EXT_GLOBAL(cfg)->persistent_servlet_connections) exit(6);
	EXT_GLOBAL(ini_updated)|=U_PERSISTENT_SERVLET_CONNECTIONS;
}
void EXT_GLOBAL(update_hosts)(const char*new_value) {
	if((EXT_GLOBAL (ini_set) &U_HOSTS)) free(EXT_GLOBAL(cfg)->hosts);
	EXT_GLOBAL(cfg)->hosts=strdup(new_value);
	assert(EXT_GLOBAL(cfg)->hosts); if(!EXT_GLOBAL(cfg)->hosts) exit(6);
	EXT_GLOBAL(ini_updated)|=U_HOSTS;
}
void EXT_GLOBAL(update_servlet)(const char*new_value) {
  if((EXT_GLOBAL (ini_set) &U_SERVLET)) free(EXT_GLOBAL(cfg)->servlet);
  if(!strncasecmp(on, new_value, 2) || !strncasecmp(on2, new_value, 1)) {
	EXT_GLOBAL(cfg)->servlet=strdup(DEFAULT_SERVLET);
	EXT_GLOBAL(cfg)->servlet_is_default=1;
  }
  else {
	EXT_GLOBAL(cfg)->servlet=strdup(new_value);
	EXT_GLOBAL(cfg)->servlet_is_default=0;
  }
  assert(EXT_GLOBAL(cfg)->servlet); if(!EXT_GLOBAL(cfg)->servlet) exit(6);
  EXT_GLOBAL(ini_updated)|=U_SERVLET;
}
void EXT_GLOBAL(update_socketname)(const char*new_value) {
	if((EXT_GLOBAL (ini_set) &U_SOCKNAME)) free(EXT_GLOBAL(cfg)->sockname);
	EXT_GLOBAL(cfg)->sockname=strdup(new_value);
#if defined(HAVE_ABSTRACT_NAMESPACE) && !defined(CFG_JAVA_SOCKET_INET)
	if (EXT_GLOBAL(cfg)->sockname[0]=='/')
	  EXT_GLOBAL(cfg)->sockname[0]='@';
#endif
	EXT_GLOBAL(cfg)->socketname_set=1;
	assert(EXT_GLOBAL(cfg)->sockname); if(!EXT_GLOBAL(cfg)->sockname) exit(6);
	EXT_GLOBAL(ini_updated)|=U_SOCKNAME;
}
static void override_hosts(const char*new_value) {
  EXT_GLOBAL(update_hosts)(new_value);
  EXT_GLOBAL(ini_override)|=U_HOSTS;
}
static void override_servlet(const char*new_value) {
  EXT_GLOBAL(update_servlet)(new_value);
  EXT_GLOBAL(ini_override)|=U_SERVLET;
}
static void override_socketname(const char*new_value) {
  EXT_GLOBAL(update_socketname)(new_value);
  EXT_GLOBAL(ini_override)|=U_SOCKNAME;
}
/*
 * check for CGI environment and set hosts so that we can connect back
 * to the sever from which we were called.
 */
static void override_ini_from_cgi(void) {
  static const char on[]="User";
  static const char key_socketname[]="java.socketname";
  static const char key_hosts[]="java.hosts";
  static const char key_servlet[] = "java.servlet";
  char *hosts;
  EXT_GLOBAL(cfg)->is_cgi_servlet=0;
  EXT_GLOBAL(cfg)->is_fcgi_servlet=0;
  
#if EXTENSION == JAVA
  if ((hosts=getenv("X_JAVABRIDGE_OVERRIDE_HOSTS"))) {
#elif EXTENSION == MONO
  if ((hosts=getenv("X_MONOBRIDGE_OVERRIDE_HOSTS"))) {
#else
  if (0) {
#endif

	switch(*hosts) {
	case '/': 				/* this is fast cgi, override
							   information will be passed via
							   X_JAVABRIDGE_REDIRECT header (see
							   override_ini_for_redirect()). */
/* 	  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet, */
/* 						   (char*)on, sizeof on, */
/* 						   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP); */
	  override_servlet(on);
	  EXT_GLOBAL(cfg)->socketname_set = 0;
	  EXT_GLOBAL(cfg)->is_cgi_servlet=1;
	  EXT_GLOBAL(cfg)->is_fcgi_servlet=1;
	  break;

	default:					/* cgi binary with redirect
								   information */
	  {
		char *kontext, *host, *val;
		val = host = strdup(hosts);
		if((host[0]=='s' || host[0]=='h') && host[1]==':') {
		  if(*host=='s') 
			EXT_GLOBAL(ini_user) |= U_SECURE;
		  else 
			EXT_GLOBAL(ini_user) &= ~U_SECURE;
		  host+=2;
		}
		kontext = strchr(host, '/');
		if(kontext) *kontext++=0;
/* 		zend_alter_ini_entry((char*)key_hosts, sizeof key_hosts, */
/* 							 host, strlen(host)+1, */
/* 							 ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP); */
		override_hosts(host);
/* 		zend_alter_ini_entry((char*)key_socketname, sizeof key_socketname, */
/* 							 (char*)off, sizeof off, */
/* 							 ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP); */
		override_socketname(off);
		EXT_GLOBAL(cfg)->socketname_set = 0;
		if(!kontext) {
/* 		  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet, */
/* 							   (char*)on, sizeof on, */
/* 							   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP); */
		  override_servlet(on);
		} else {
/* 		  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet, */
/* 							   (char*)kontext, strlen(kontext)+1, */
/* 							   ZEND_INI_SYSTEM, PHP_INI_STAGE_STARTUP); */
		  override_servlet(kontext);
		}
		free(val);
	  }
	  /* fall through */
	case 0:					/* cgi binary, but redirect is off */
	  EXT_GLOBAL(cfg)->is_cgi_servlet=1;
	}
  }
}

void EXT_GLOBAL (init_cfg) (TSRMLS_D) {

#ifdef CFG_JAVA_SOCKET_INET
  EXT_GLOBAL(cfg)->java_socket_inet = 1;
#else
  EXT_GLOBAL(cfg)->java_socket_inet = 0;
#endif

  override_ini_from_cgi();

  if(!(EXT_GLOBAL (ini_updated) &U_SOCKNAME)) EXT_GLOBAL(cfg)->sockname=strdup("");
  if(!(EXT_GLOBAL (ini_updated) &U_SERVLET)) EXT_GLOBAL(cfg)->servlet=strdup(DEFAULT_SERVLET);
  if(!(EXT_GLOBAL (ini_updated) &U_HOSTS)) EXT_GLOBAL(cfg)->hosts=strdup("");
  if(!(EXT_GLOBAL (ini_updated) &U_PERSISTENT_SERVLET_CONNECTIONS)) EXT_GLOBAL(cfg)->persistent_servlet_connections=strdup("");
  if(!(EXT_GLOBAL (ini_updated) &U_LOGLEVEL)) {
	EXT_GLOBAL(cfg)->logLevel=strdup(DEFAULT_LEVEL);
	EXT_GLOBAL(cfg)->logLevel_val=atoi(DEFAULT_LEVEL);
  }
  EXT_GLOBAL(ini_set)=~0;
  EXT_GLOBAL(ini_user)|=EXT_GLOBAL(ini_updated);
  EXT_GLOBAL(ini_updated)=0;
}

void EXT_GLOBAL (destroy_cfg) (int EXT_GLOBAL (ini_updated) ) {
  assert(EXT_GLOBAL(ini_updated) == ~0);
  if(!(EXT_GLOBAL (ini_updated) &U_SERVLET)) free(EXT_GLOBAL(cfg)->servlet);
  if(!(EXT_GLOBAL (ini_updated) &U_HOSTS)) free(EXT_GLOBAL(cfg)->hosts);
  if(!(EXT_GLOBAL (ini_updated) &U_PERSISTENT_SERVLET_CONNECTIONS)) free(EXT_GLOBAL(cfg)->persistent_servlet_connections);

  if(!(EXT_GLOBAL (ini_updated) &U_SOCKNAME)) free(EXT_GLOBAL(cfg)->sockname); 

  if(!(EXT_GLOBAL (ini_updated) &U_LOGLEVEL)) free(EXT_GLOBAL(cfg)->logLevel);
}

/*
 * return true only if the _user_ has set the option to true (not
 * "off").
 */
short EXT_GLOBAL(option_set_by_user)(short option, int ini_user) {
  static const char off[]="Off";
  char *entry = 0;

  if((option & ini_user)==0) return 0;

  switch(option) {
  case U_LOGLEVEL: entry = EXT_GLOBAL(cfg)->logLevel; break;
  case U_SOCKNAME: entry = EXT_GLOBAL(cfg)->sockname; break;
  case U_HOSTS:    entry = EXT_GLOBAL(cfg)->hosts; break; 
  case U_SERVLET:  entry = EXT_GLOBAL(cfg)->servlet; break;
  case U_PERSISTENT_SERVLET_CONNECTIONS:  entry = EXT_GLOBAL(cfg)->persistent_servlet_connections; break;
  default: assert(0);
  }  

  if (!entry || !*entry) return 0;
  if(!strncasecmp(off, entry, 3)) {
	*entry=0;
	return 0;
  }
  return 1;
}

#ifndef PHP_WRAPPER_H
#error must include php_wrapper.h
#endif
